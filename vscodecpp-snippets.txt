{
    "ttemplate": {
        "prefix": "ttemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "using namespace std;",
            "",
            "void solve() {",
            "\t$0",
            "",
            "}",
            "",
            "int main() {",
            "\tcin.tie(nullptr)->sync_with_stdio(false);",
            "\tcin.exceptions(cin.failbit);",
            "\tint T = 1;",
            "\tcin >> T;",
            "\tfor (int i = 1; i <= T; i++) {",
            "\t\tsolve();",
            "\t}",
            "}"
        ],
        "description": "c++ template with test cases"
    },
    "template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "using namespace std;",
            "",
            "void solve() {",
            "\t$0",
            "",
            "}",
            "",
            "int main() {",
            "\tcin.tie(nullptr)->sync_with_stdio(false);",
            "\tcin.exceptions(cin.failbit);",
            "\tsolve();",
            "}"
        ],
        "description": "c++ template"
    },
    "blank": {
        "prefix": "blank template",
        "body": [
            "#include <bits/stdc++.h>",
            "typedef long long ll;",
            "using namespace std;",
            "",
            "int main() {",
            "\t$0",
            "",
            "}"
        ],
        "description": "blank c++ template"
    },
    "freopen": {
        "prefix": "openfile",
        "body": [
            "freopen(\"${1:${TM_FILENAME_BASE}}.in\", \"r\", stdin);",
            "freopen(\"${1:${TM_FILENAME_BASE}}.out\", \"w\", stdout);"
        ],
        "description": "use file input output"
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "auto start_time = chrono::steady_clock::now();",
            "auto end_time = chrono::steady_clock::now();",
            "cout << \"\\nruntime: \" << fixed << setprecision(2)",
            "    << chrono::duration_cast<chrono::nanoseconds>(end_time - start_time).count() / 1e6",
            "    << \" ms\\n\";"
        ],
        "description": "timer"
    },
    "random": {
        "prefix": "random",
        "body": [
            "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) // [a, b]",
            "mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "random"
    },
    "unsigned long long": {
        "prefix": "unsigned long long",
        "body": [
            "typedef __uint128_t ull;"
        ],
        "description": "type definition ull"
    },
    "modular int": {
        "prefix": "modular int",
        "body": [
            "const int MOD = int(1e9) + 7;",
            "struct Mint {",
            "    ll value;",
            "    Mint(ll v = 0) { value = v % MOD; if (value < 0) value += MOD; }",
            "    Mint(ll a, ll b) : value(0) { *this += a; *this /= b; }",
            "",
            "    Mint& operator+=(Mint const& b) { value += b.value; if (value >= MOD) value -= MOD; return *this; }",
            "    Mint& operator-=(Mint const& b) { value -= b.value; if (value < 0) value += MOD; return *this; }",
            "    Mint& operator*=(Mint const& b) { value = value * b.value % MOD; return *this; }",
            "",
            "    friend Mint mexp(Mint a, ll e) {",
            "        Mint res = 1; while (e) { if (e & 1) res *= a; a *= a; e >>= 1; }",
            "        return res;",
            "    }",
            "    friend Mint inverse(Mint a) { return mexp(a, MOD - 2); }",
            "",
            "    Mint& operator/=(Mint const& b) { return *this *= inverse(b); }",
            "    friend Mint operator+(Mint a, Mint const b) { return a += b; }",
            "    friend Mint operator-(Mint a, Mint const b) { return a -= b; }",
            "    friend Mint operator-(Mint const a) { return 0 - a; }",
            "    friend Mint operator*(Mint a, Mint const b) { return a *= b; }",
            "    friend Mint operator/(Mint a, Mint const b) { return a /= b; }",
            "    friend std::ostream& operator<<(std::ostream& os, Mint const& a) { return os << a.value; }",
            "    friend bool operator==(Mint const& a, Mint const& b) { return a.value == b.value; }",
            "    friend bool operator!=(Mint const& a, Mint const& b) { return a.value != b.value; }",
            "};"
        ],
        "description": "modular int"
    },
    "vector vector int": {
        "prefix": "vvi",
        "body": "vector<vector<int>> ${1:vvi}($2, vector<int>($3));",
        "description": "vector vector int"
    },
    "vector vector long long": {
        "prefix": "vvll",
        "body": "vector<vector<ll>> ${1:vvll}($2, vector<ll>($3));",
        "description": "vector vector long long"
    },
    "vector int": {
        "prefix": "vi",
        "body": "vector<int>",
        "description": "vector int"
    },
    "vector bool": {
        "prefix": "vb",
        "body": "vector<bool>",
        "description": "vector int"
    },
    "vector long long": {
        "prefix": "vll",
        "body": "vector<ll>",
        "description": "vector long long"
    },
    "vector string": {
        "prefix": "vs",
        "body": "vector<string>",
        "description": "vector string"
    },
    "pair int int": {
        "prefix": "pii",
        "body": "pair<int, int>",
        "description": "pair int int"
    },
    "pair long long long long": {
        "prefix": "pll",
        "body": "pair<ll, ll>",
        "description": "pair long long"
    },
    "sieve of eratosthenes prime": {
        "prefix": "sieve",
        "body": [
            "const int N = int(1e6);",
            "int primes[N];",
            "vector<int> pr;",
            "",
            "void sieve(){",
            "    for(int i = 2; i < N; i++){",
            "        if(primes[i] == 0){",
            "            pr.push_back(i);",
            "            for(int j = i * i; j < N; j += i){",
            "                primes[j] = 1;",
            "            }",
            "        }",
            "        primes[i] ^= 1;",
            "    }",
            "}",
            ""
        ],
        "description": "prime sieve"
    },
    "Miller-Rabin Prime Check": {
        "prefix": [
            "miller-rabin"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "    ll ret = a * b - M * ull(1.L / M * a * b);",
            "    return ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "    ull ans = 1;",
            "    for (; e; b = modmul(b, b, mod), e /= 2)",
            "        if (e & 1) ans = modmul(ans, b, mod);",
            "    return ans;",
            "}",
            "bool isPrime(ull n) { // Miller-Rabin",
            "    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "    ull A[] = { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 },",
            "        s = __builtin_ctzll(n - 1), d = n >> s;",
            "    for (ull a : A) { // ^ count trailing zeroes",
            "        ull p = modpow(a % n, d, n), i = s;",
            "        while (p != 1 && p != n - 1 && a % n && i--)",
            "            p = modmul(p, p, n);",
            "        if (p != n - 1 && i != s) return 0;",
            "    }",
            "    return 1;",
            "}",
            ""
        ],
        "description": ""
    },
    "Pollard's rho factorize": {
        "prefix": [
            "pollard rho"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "    ll ret = a * b - M * ull(1.L / M * a * b);",
            "    return ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "    ull ans = 1;",
            "    for (; e; b = modmul(b, b, mod), e /= 2)",
            "        if (e & 1) ans = modmul(ans, b, mod);",
            "    return ans;",
            "}",
            "bool isPrime(ull n) { // Miller-Rabin",
            "    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "    ull A[] = { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 },",
            "        s = __builtin_ctzll(n - 1), d = n >> s;",
            "    for (ull a : A) { // ^ count trailing zeroes",
            "        ull p = modpow(a % n, d, n), i = s;",
            "        while (p != 1 && p != n - 1 && a % n && i--)",
            "            p = modmul(p, p, n);",
            "        if (p != n - 1 && i != s) return 0;",
            "    }",
            "    return 1;",
            "}",
            "ull pollard(ull n) {",
            "    auto f = [n](ull x) { return modmul(x, x, n) + 1; };",
            "    ull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
            "    while (t++ % 40 || __gcd(prd, n) == 1) {",
            "        if (x == y) x = ++i, y = f(x);",
            "        if ((q = modmul(prd, max(x, y) - min(x, y), n))) prd = q;",
            "        x = f(x), y = f(f(y));",
            "    }",
            "    return __gcd(prd, n);",
            "}",
            "vector<ull> factor(ull n) { // Pollard's rho",
            "    if (n == 1) return {};",
            "    if (isPrime(n)) return { n };",
            "    ull x = pollard(n);",
            "    auto l = factor(x), r = factor(n / x);",
            "    l.insert(l.end(), r.begin(), r.end());",
            "    return l;",
            "}",
            ""
        ],
        "description": ""
    },
    "Convex Hull": {
        "prefix": "hull",
        "body": [
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "    typedef Point P;",
            "    T x, y;",
            "    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }",
            "    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }",
            "    P operator+(P p) const { return P(x + p.x, y + p.y); }",
            "    P operator-(P p) const { return P(x - p.x, y - p.y); }",
            "    P operator*(T d) const { return P(x * d, y * d); }",
            "    P operator/(T d) const { return P(x / d, y / d); }",
            "    T dot(P p) const { return x * p.x + y * p.y; }",
            "    T cross(P p) const { return x * p.y - y * p.x; }",
            "    T cross(P a, P b) const { return (a - *this).cross(b - *this); }",
            "    T dist2() const { return x * x + y * y; }",
            "    double dist() const { return sqrt((double)dist2()); }",
            "    // angle to x=axis in interva l [=pi , pi ]",
            "    double angle() const { return atan2(y, x); }",
            "    P unit() const { return *this / dist(); } // makes d is t ()=1",
            "    P perp() const { return P(-y, x); } // rotates +90 degrees",
            "    P normal() const { return perp().unit(); }",
            "    // returns point rotated 'a' radians ccw around the origin",
            "    P rotate(double a) const {",
            "        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "    }",
            "    friend ostream& operator<<(ostream& os, P p) {",
            "        return os << \"(\" << p.x << \",\" << p.y << \")\";",
            "    }",
            "};",
            "",
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "    if (pts.size() <= 1) return pts;",
            "    sort(pts.begin(), pts.end());",
            "    vector<P> h(pts.size() + 1);",
            "    int s = 0, t = 0;",
            "    for (int it = 2; it--; s = --t, reverse(pts.begin(), pts.end()))",
            "        for (P p : pts) {",
            "            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;",
            "            h[t++] = p;",
            "        }",
            "    return { h.begin(), h.begin() + t - (t == 2 && h[0] == h[1]) };",
            "}",
            ""
        ],
        "description": "Convex Hull"
    },
    "Convex Hull Diameter": {
        "prefix": "hull diameter",
        "body": [
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "    typedef Point P;",
            "    T x, y;",
            "    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }",
            "    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }",
            "    P operator+(P p) const { return P(x + p.x, y + p.y); }",
            "    P operator-(P p) const { return P(x - p.x, y - p.y); }",
            "    P operator*(T d) const { return P(x * d, y * d); }",
            "    P operator/(T d) const { return P(x / d, y / d); }",
            "    T dot(P p) const { return x * p.x + y * p.y; }",
            "    T cross(P p) const { return x * p.y - y * p.x; }",
            "    T cross(P a, P b) const { return (a - *this).cross(b - *this); }",
            "    T dist2() const { return x * x + y * y; }",
            "    double dist() const { return sqrt((double)dist2()); }",
            "    // angle to x=axis in interva l [=pi , pi ]",
            "    double angle() const { return atan2(y, x); }",
            "    P unit() const { return *this / dist(); } // makes d is t ()=1",
            "    P perp() const { return P(-y, x); } // rotates +90 degrees",
            "    P normal() const { return perp().unit(); }",
            "    // returns point rotated 'a' radians ccw around the origin",
            "    P rotate(double a) const {",
            "        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "    }",
            "    friend ostream& operator<<(ostream& os, P p) {",
            "        return os << \"(\" << p.x << \",\" << p.y << \")\";",
            "    }",
            "};",
            "",
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "    if (pts.size() <= 1) return pts;",
            "    sort(pts.begin(), pts.end());",
            "    vector<P> h(pts.size() + 1);",
            "    int s = 0, t = 0;",
            "    for (int it = 2; it--; s = --t, reverse(pts.begin(), pts.end()))",
            "        for (P p : pts) {",
            "            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;",
            "            h[t++] = p;",
            "        }",
            "    return { h.begin(), h.begin() + t - (t == 2 && h[0] == h[1]) };",
            "}",
            "",
            "array<P, 2> hullDiameter(vector<P> S) {",
            "    int n = (int)S.size(), j = n < 2 ? 0 : 1;",
            "    pair<ll, array<P, 2>> res({ 0, {S[0], S[0]} });",
            "    for (int i = 0; i < j; i++)",
            "        for (;; j = (j + 1) % n) {",
            "            res = max(res, { (S[i] - S[j]).dist2(), {S[i], S[j]} });",
            "            if ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
            "                break;",
            "        }",
            "    return res.second;",
            "}",
            ""
        ],
        "description": "Convex Hull"
    },
    "powermod": {
        "prefix": [
            "modpow",
            "karatsuba"
        ],
        "body": [
            "const int MOD = int(1e9) + 7;",
            "",
            "ll powmod(ll base, ll exp) {",
            "\tbase %= MOD;",
            "\tll result = 1;",
            "\twhile (exp > 0) {",
            "\t\tif (exp & 1) result = (result * base) % MOD;",
            "\t\tbase = (base * base) % MOD;",
            "\t\texp >>= 1;",
            "\t}",
            "\treturn result;",
            "}",
            ""
        ],
        "description": "a^b % MOD, karatsuba multiplication"
    },
    "nCr": {
        "prefix": [
            "choose",
            "comb"
        ],
        "body": [
            "const int MOD = int(1e9) + 7;",
            "vector<ll> fact;",
            "",
            "void initFact(int n, int p) {",
            "\tfact = vector<ll>(n + 1);",
            "\tfact[0] = fact[1] = 1;",
            "\tfor (int i = 2; i <= n; i++) {",
            "\t\tfact[i] = fact[i - 1] * i;",
            "\t\tfact[i] %= p;",
            "\t}",
            "}",
            "",
            "ll powmod(ll a, ll b, ll p) {",
            "\ta %= p;",
            "\tif (a == 0) return 0;",
            "\tll product = 1;",
            "\twhile (b > 0) {",
            "\t\tif (b & 1) {",
            "\t\t\tproduct *= a;",
            "\t\t\tproduct %= p;",
            "\t\t\t--b;",
            "\t\t}",
            "\t\ta *= a;",
            "\t\ta %= p;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn product;",
            "}",
            "",
            "ll inv(ll a, ll p) {",
            "\treturn powmod(a, p - 2, p);",
            "}",
            "",
            "ll nCr(ll n, ll k, ll p) {",
            "\treturn ((fact[n] * inv(fact[k], p) % p) * inv(fact[n - k], p)) % p;",
            "}",
            "",
            "ll nCr(ll n, ll k) {",
            "\tif (k > n || k < 0) return 0;",
            "\treturn nCr(n, k, MOD);",
            "}",
            ""
        ],
        "description": "combination"
    },
    "Union Find": {
        "prefix": "unionfind",
        "body": [
            "struct UF {",
            "    vector<int> e;",
            "    UF(int n) : e(n, -1) {}",
            "    bool sameSet(int a, int b) { return find(a) == find(b); }",
            "    int size(int x) { return -e[find(x)]; }",
            "    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
            "    bool join(int a, int b) {",
            "        a = find(a), b = find(b);",
            "        if (a == b) return false;",
            "        if (e[a] > e[b]) swap(a, b);",
            "        e[a] += e[b]; e[b] = a;",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Union Find"
    },
    "Fenwick Tree / Binary Indexed Tree": {
        "prefix": [
            "binaryindextree",
            "fenwicktree"
        ],
        "body": [
            "struct FT { // fenwick tree [l, r], 0 indexed",
            "    vector<ll> bit;",
            "    int n;",
            "    FT(int n) : bit(n, 0), n(n) {}",
            "    ll sum(int r) {",
            "        ll ret = 0;",
            "        for (; r >= 0; r = (r & (r + 1)) - 1)",
            "            ret += bit[r];",
            "        return ret;",
            "    }",
            "    ll sum(int l, int r) { return sum(r) - sum(l - 1); }",
            "    void add(int idx, ll delta) {",
            "        for (; idx < n; idx = idx | (idx + 1))",
            "            bit[idx] += delta;",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree, [l, r] inclusive 0 indexed"
    },
    "FenwickTree2D": {
        "prefix": "fenwicktree2d",
        "body": [
            "struct FT2D {",
            "    vector<vector<ll>> bit;",
            "    int n, m;",
            "",
            "    FT2D(int n, int m) {",
            "        this->n = n;",
            "        this->m = m;",
            "        this->bit = vector<vector<ll>>(n, vector<ll>(m));",
            "    }",
            "",
            "    // 2d sum from (0, 0)",
            "    ll sum(int x, int y) {",
            "        ll ret = 0;",
            "        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)",
            "            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)",
            "                ret += bit[i][j];",
            "        return ret;",
            "    }",
            "",
            "    // x2 >= x1, y2 >= y1, make sure x1, y1 are greater than 0",
            "    ll sum2d(int x1, int y1, int x2, int y2) {",
            "        // assert(x1 > 0 && y1 > 0);",
            "        x1--, y1--;",
            "        return this->sum(x2, y2)",
            "            - this->sum(x1, y2) - this->sum(x2, y1)",
            "            + this->sum(x1, y1);",
            "    }",
            "",
            "    void add(int x, int y, ll delta) {",
            "        for (int i = x; i < n; i = i | (i + 1))",
            "            for (int j = y; j < m; j = j | (j + 1))",
            "                bit[i][j] += delta;",
            "    }",
            "};"
        ],
        "description": "2D Fenwick Tree, 0 indexed"
    },
    "Rabin-Karp": {
        "prefix": "rabin karp",
        "body": [
            "$1mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());",
            "const int p = uniform_int_distribution<int>(0, MOD - 1)(rng);",
            "const int MX_len = int(2e5) + 5;",
            "Mint curr(1);",
            "for (int i = 1; i < MX_len; i++) {",
            "    pows.push_back(curr);",
            "    curr *= p;",
            "}",
            "// ^MOVE TO MAIN",
            "vector<Mint> pows;",
            "Mint compute_hash(string const& s) {",
            "    Mint hash_val(0);",
            "    for (int i = 0; i < (int)s.size(); i++) {",
            "        hash_val += (s[i] - 'a' + 1) * pows[i];",
            "    }",
            "    return hash_val;",
            "}",
            "void subtract(Mint& hash_val, int pos, string& s) {",
            "    hash_val -= (s[pos] - 'a' + 1) * pows[pos];",
            "}",
            "void add(Mint& hash_val, int pos, string& s) {",
            "    hash_val += (s[pos] - 'a' + 1) * pows[pos];",
            "}"
        ],
        "description": "Rabin-Karp string hashing"
    },
    "RMQ": {
        "prefix": "segtree set",
        "body": [
          "/*  RMQ lazy segment tree with set operation",
          "    update(a,b,x): SET range [a, b) to x",
          "    query(a,b): find minimum of range [a, b)",
          "    (JP) from https://algo-logic.info/",
          "*/",
          "template <typename T>",
          "struct RMQ {",
          "    const T INF = numeric_limits<T>::max();",
          "    int n;",
          "    vector<T> dat, lazy;",
          "    RMQ(int n_) : n(), dat(n_ * 4, INF), lazy(n_ * 4, INF) {",
          "        int x = 1;",
          "        while (n_ > x) x *= 2;",
          "        n = x;",
          "    }",
          "",
          "    /* lazy eval */",
          "    void eval(int k) {",
          "        if (lazy[k] == INF) return;",
          "        if (k < n - 1) {",
          "            lazy[k * 2 + 1] = lazy[k];",
          "            lazy[k * 2 + 2] = lazy[k];",
          "        }",
          "        dat[k] = lazy[k];",
          "        lazy[k] = INF;",
          "    }",
          "",
          "    void update(int a, int b, T x, int k, int l, int r) {",
          "        eval(k);",
          "        if (a <= l && r <= b) {",
          "            lazy[k] = x;",
          "            eval(k);",
          "        } else if (a < r && l < b) {",
          "            update(a, b, x, k * 2 + 1, l, (l + r) / 2);",
          "            update(a, b, x, k * 2 + 2, (l + r) / 2, r);",
          "            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);",
          "        }",
          "    }",
          "    void update(int a, int b, T x) { update(a, b, x, 0, 0, n); }",
          "",
          "    T query_sub(int a, int b, int k, int l, int r) {",
          "        eval(k);",
          "        if (r <= a || b <= l) {",
          "            return INF;",
          "        } else if (a <= l && r <= b) {",
          "            return dat[k];",
          "        } else {",
          "            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
          "            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
          "            return min(vl, vr);",
          "        }",
          "    }",
          "    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
          "",
          "    /* debug */",
          "    inline T operator[](int a) { return query(a, a + 1); }",
          "    void print() {",
          "        for (int i = 0; i < 2 * n - 1; ++i) {",
          "            cout << (*this)[i];",
          "            if (i != n) cout << \",\";",
          "        }",
          "        cout << endl;",
          "    }",
          "};"
        ],
        "description": ""
    },
    "RMQ2": {
        "prefix": "segtree add",
        "body": [
          "/*  RMQ lazy segment tree with add operation",
          "    update(a,b,x): ADD x to range [a, b)",
          "    query(a,b): find minimum of range [a, b)",
          "    (JP) from https://algo-logic.info/",
          "*/",
          "template <typename T>",
          "struct RMQ {",
          "    const T INF = numeric_limits<T>::max();",
          "    int n;",
          "    vector<T> dat, lazy;",
          "    RMQ(int n_) : n(), dat(n_ * 4, 0), lazy(n_ * 4, 0) {",
          "        int x = 1;",
          "        while (n_ > x) x *= 2;",
          "        n = x;",
          "    }",
          "",
          "    /* lazy eval */",
          "    void eval(int k) {",
          "        if (lazy[k] == 0) return;",
          "        if (k < n - 1) {",
          "            lazy[k * 2 + 1] += lazy[k];",
          "            lazy[k * 2 + 2] += lazy[k];",
          "        }",
          "",
          "        dat[k] += lazy[k];",
          "        lazy[k] = 0;",
          "    }",
          "    void update(int a, int b, T x, int k, int l, int r) {",
          "        eval(k);",
          "        if (a <= l && r <= b) {",
          "            lazy[k] += x;",
          "            eval(k);",
          "        } else if (a < r && l < b) {",
          "            update(a, b, x, k * 2 + 1, l, (l + r) / 2);",
          "            update(a, b, x, k * 2 + 2, (l + r) / 2, r);",
          "            dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);",
          "        }",
          "    }",
          "    void update(int a, int b, T x) { update(a, b, x, 0, 0, n); }",
          "",
          "    T query_sub(int a, int b, int k, int l, int r) {",
          "        eval(k);",
          "        if (r <= a || b <= l) {",
          "            return INF;",
          "        } else if (a <= l && r <= b) {",
          "            return dat[k];",
          "        } else {",
          "            T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
          "            T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
          "            return min(vl, vr);",
          "        }",
          "    }",
          "    T query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
          "",
          "    /* debug */",
          "    inline T operator[](int a) { return query(a, a + 1); }",
          "    void print() {",
          "        for (int i = 0; i < 2 * n - 1; ++i) {",
          "            cout << (*this)[i];",
          "            if (i != n) cout << \",\";",
          "        }",
          "        cout << endl;",
          "    }",
          "};"
        ],
        "description": ""
    },
    "kactl": {
        "prefix": "kactl",
        "body": [
            "#define rep(i, a, b) for (int i = a; i < (b); ++i)",
            "#define all(x) x.begin(), x.end()",
            "#define sz(x) (int)(x).size()",
            "typedef pair<int, int> pii;",
            "typedef vector<int> vi;"
        ],
        "description": "kactl typedefs"
    }
}
